# Этап 1 — Ассемблер УВМ (Вариант 30)
## Автор: Сысоев Даниил Денисович, ИКБО-71-24  

## 1. Что происходит в этапе

Этап 1 заключается в создании минимального ассемблера, который:

* принимает программу в формате **YAML**;
* формирует внутреннее представление инструкций (A, B);
* кодирует их в 32-битные машинные слова согласно условиям варианта 30;
* в режиме `--test` выводим:

  * IR (список инструкций с полями A/B),
  * hex-дамп полученного бинарника,
  * размер сгенерированного `.bin` файла.

#  ВАЖНО Установить зависимости:

```bash
pip install -r requirements.txt
```

---

### Запуск в тестовом режиме

Создать папку для бинарников:

```bash
mkdir build
```
Собрать и протестировать программу:
```bash
python assembler.py programs/tests.yaml build/tests.bin --test
```
### Что выдаёт `--test`:
1. Внутреннее представление инструкций (A, B).
2. Hex-дамп 32-битных слов.
3. Размер итогового бинарного файла.
Вывод должен совпадать с тестами из спецификации:
* CONST 480 → `08 3C 00 00`
* LOAD 91 → `75 0B 00 00`
* STORE → `1C 00 00 00`
* MAX 6 → `D9 00 00 00`



---

# 3. Спроектированный язык ассемблера (формат входной программы)1

В рамках Этапа 1 был разработан простой и человекочитаемый язык ассемблера для учебной виртуальной машины (УВМ), вариант 30.
В качестве формата представления программы выбран **YAML**, так как он:

* легко читается человеком;
* формирует структуру данных, которую удобно обрабатывать в Python;
* естественно подходит для списков инструкций.

---

## 3.1. Общий формат файла программы

Программа представляет собой **список инструкций**, каждая из которых оформлена в виде YAML-объекта следующего вида:

```yaml
- { op: <имя_команды>, <аргументы> }
```

Каждая инструкция находится на отдельной строке и имеет обязательное поле:

* `op` — имя операции (команды), регистр не важен.

Дополнительные поля (`value`, `addr`, `offset`) зависят от типа команды.

Например:

```yaml
- { op: CONST, value: 480 }
- { op: LOAD,  addr: 91 }
- { op: STORE }
- { op: MAX,   offset: 6 }
```

---

## 3.2. Поддерживаемые инструкции (вариант 30)

Ассемблер реализует четыре команды, определённые спецификацией УВМ для варианта 30.
Для каждой команды задаётся:

* имя (`op`);
* аргументы, необходимые для вычисления поля B;
* назначение команды.

### **1) CONST**

```yaml
- { op: CONST, value: <число> }
```

| Аргумент | Описание                                                                             |
| -------- | ------------------------------------------------------------------------------------ |
| `value`  | Константа, которая кодируется в поле B и помещается на вершину стека при исполнении. |

### **2) LOAD**

```yaml
- { op: LOAD, addr: <адрес> }
```

| Аргумент | Описание                                                                |
| -------- | ----------------------------------------------------------------------- |
| `addr`   | Адрес в памяти; при исполнении значение `mem[addr]` помещается на стек. |

### **3) STORE**

```yaml
- { op: STORE }
```

Команда не принимает аргументов.
При исполнении берёт со стека два значения: адрес и данные, и записывает данные в память по указанному адресу.

### **4) MAX**

```yaml
- { op: MAX, offset: <смещение> }
```

| Аргумент | Описание                                                                                                                                                                      |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `offset` | Смещение, добавляемое к базовому адресу, снимаемому со стека. Команда вычисляет максимум двух операндов: значения в памяти `mem[base + offset]` и значения, лежащего в стеке. |

---

## 3.3. Валидация аргументов

Ассемблер проверяет:

1. корректность имени команды;
2. наличие обязательных аргументов (`value`, `addr`, `offset`);
3. соответствие аргументов допустимому диапазону поля B:

   * CONST → 21 бит
   * LOAD → 24 бита
   * MAX → 13 бит

Если значение не помещается в указанный диапазон, ассемблер выдаёт ошибку.

---

## 3.4. Преимущества выбранного формата

Использование YAML позволяет:

* минимизировать синтаксические ошибки;
* упростить разбор и обработку инструкций;
* легко добавлять новые команды в будущем;
* обеспечивать читаемость и прозрачность входной программы.

Такой формат является удобным для учебного ассемблера и полностью удовлетворяет требованиям Этапа 1.



---
## 4. Результат Этапа 1
После выполнения Этапа 1 у нас есть:
* рабочий ассемблер для варианта 30;
* проверка на тестах из задания;
* генерация бинарного `.bin` файла;
* вывод IR и hex-дампа.




---

# 3. Спроектированный язык ассемблера (формат входной программы)

В рамках Этапа 1 был разработан простой и человекочитаемый язык ассемблера для учебной виртуальной машины (УВМ), вариант 30.
В качестве формата представления программы выбран **YAML**, так как он:

* легко читается человеком;
* формирует структуру данных, которую удобно обрабатывать в Python;
* естественно подходит для списков инструкций.

---

## 3.1. Общий формат файла программы

Программа представляет собой **список инструкций**, каждая из которых оформлена в виде YAML-объекта следующего вида:

```yaml
- { op: <имя_команды>, <аргументы> }
```

Каждая инструкция находится на отдельной строке и имеет обязательное поле:

* `op` — имя операции (команды), регистр не важен.

Дополнительные поля (`value`, `addr`, `offset`) зависят от типа команды.

Например:

```yaml
- { op: CONST, value: 480 }
- { op: LOAD,  addr: 91 }
- { op: STORE }
- { op: MAX,   offset: 6 }
```

---

## 3.2. Поддерживаемые инструкции (вариант 30)

Ассемблер реализует четыре команды, определённые спецификацией УВМ для варианта 30.
Для каждой команды задаётся:

* имя (`op`);
* аргументы, необходимые для вычисления поля B;
* назначение команды.

### **1) CONST**

```yaml
- { op: CONST, value: <число> }
```

| Аргумент | Описание                                                                             |
| -------- | ------------------------------------------------------------------------------------ |
| `value`  | Константа, которая кодируется в поле B и помещается на вершину стека при исполнении. |

### **2) LOAD**

```yaml
- { op: LOAD, addr: <адрес> }
```

| Аргумент | Описание                                                                |
| -------- | ----------------------------------------------------------------------- |
| `addr`   | Адрес в памяти; при исполнении значение `mem[addr]` помещается на стек. |

### **3) STORE**

```yaml
- { op: STORE }
```

Команда не 12принимает аргументов.
При исполнении берёт со стека два значения: адрес и данные, и записывает данные в память по указанному адресу.

### **4) MAX**

```yaml
- { op: MAX, offset: <смещение> }
```

| Аргумент | Описание                                                                                                                                                                      |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `offset` | Смещение, добавляемое к базовому адресу, снимаемому со стека. Команда вычисляет максимум двух операндов: значения в памяти `mem[base + offset]` и значения, лежащего в стеке. |

---

## 3.3. Валидация аргументов

Ассемблер проверяет:

1. корректность имени команды;
2. наличие обязательных аргументов (`value`, `addr`, `offset`);
3. соответствие аргументов допустимому диапазону поля B:

   * CONST → 21 бит
   * LOAD → 24 бита
   * MAX → 13 бит

Если значение не помещается в указанный диапазон, ассемблер выдаёт ошибку.

---

## 3.4. Преимущества выбранного формата

Использование YAML позволяет:

* минимизировать синтаксические ошибки;
* упростить разбор и обработку инструкций;
* легко добавлять новые команды в будущем;
* обеспечивать читаемость и прозрачность входной программы.

Такой формат является удобным для учебного ассемблера и полностью удовлетворяет требованиям Этапа 1.


## Этап 2 — Формирование машинного кода

На втором этапе задача ассемблера — не только разобрать входную программу, но и **сформировать корректный бинарный файл с машинным кодом УВМ**.

### 2.1. Формат машинного слова

Каждая команда УВМ кодируется одним 32-битным словом (4 байта) в формате *little-endian*:

- биты **0–4** — поле `A` (код операции);
- биты **5..N** — поле `B` (аргумент команды), разрядность зависит от операции:
  - `CONST` — 21 бит (5–25);
  - `LOAD`  — 24 бита (5–28);
  - `MAX`   — 13 бит (5–17);
  - `STORE` — поле `B` отсутствует.

Машинное слово формируется так:

```python
value = A
if B is not None:
    value |= (B << 5)
value &= 0xFFFFFFFF  # защита от переполнения
```

# Этап 3 — Интерпретатор УВМ 

## 1. Что происходит в этапе

Этап 3 посвящён реализации **интерпретатора** (виртуальной машины), который:

* загружает бинарный файл `.bin`, сформированный ассемблером;
* декодирует каждое 32-битное машинное слово в поля `A` и `B`;
* выполняет команды на стековой модели вычислений;
* использует **объединённую память** для команд и данных;
* по завершении работы сохраняет **дамп памяти** в отдельный XML-файл для указанного диапазона адресов.

Интерпретатор реализован в файле `interpreter.py`.

---

## 2. Модель памяти и стек

Виртуальная машина описана классом `VM`:

* `mem: dict[int, int]` — объединённая память (код и данные в одном адресном пространстве), где ключ — адрес, значение — 32-битное число;
* `stack: list[int]` — стек значений, где вершина стека — конец списка;
* `pc: int` — счётчик команд (program counter), хранит индекс текущей команды;
* `prog_len: int` — количество команд в загруженной программе.

Код программы загружается в память начиная с адреса `0`:

```python
blob = pathlib.Path(path).read_bytes()
words = [int.from_bytes(blob[i:i + 4], "little") for i in range(0, len(blob), 4)]
for i, w in enumerate(words):
    self.mem_set(i, w)  # код программы занимает адреса 0..prog_len-1
self.prog_len = len(words)
self.pc = 0
````

Таким образом, команды и данные находятся в одной и той же памяти, как и требуется по условию варианта.

---

## 3. Декодирование машинного слова

Для перехода от машинного представления к промежуточному используется функция `decode_word`:

```python
def decode_word(word: int):
    A = word & 0x1F           # 5 младших бит
    name, B_bits = LAYOUT[A]  # определяем команду по A
    if B_bits:
        B = (word >> 5) & ((1 << B_bits) - 1)
    else:
        B = None
    return A, name, B
```

Где:

* `A` — код операции (5 младших бит),
* `name` — имя команды (`CONST`, `LOAD`, `STORE`, `MAX`),
* `B` — аргумент команды, восстановленный из соответствующего количества бит.

---

## 4. Реализованные команды

Интерпретатор поддерживает команды варианта 30:

### **1) CONST** (A = 8, 21 бит B)

```python
# CONST B: положить константу B на стек
self.stack.append(B)
```

Кладёт константу `B` на вершину стека.

---

### **2) LOAD** (A = 21, 24 бита B)

```python
# LOAD B: прочитать mem[B] и положить на стек
val = self.mem_get(B)
self.stack.append(val)
```

Читает значение из памяти по адресу `B` и кладёт его на стек.

---

### **3) STORE** (A = 28, без поля B)

```python
# STORE: снять со стека АДРЕС и ЗНАЧЕНИЕ, записать в память
# стек: [..., VALUE, ADDR]
addr = self.stack.pop()   # адрес
val  = self.stack.pop()   # значение
self.mem_set(addr, val)
```

Снимает со стека два значения: **адрес** и **данные**, затем записывает данные по указанному адресу.

---

### **4) MAX** (A = 25, 13 бит B)

```python
# MAX B:
# стек перед командой: [..., X, BASE]
# первый операнд: mem[BASE + B]
# второй операнд: X
base_addr = self.stack.pop()
x = self.stack.pop()
y = self.mem_get(base_addr + B)
self.stack.append(max(x, y))
```

Команда вычисляет максимум между значением в памяти (`mem[BASE + offset]`)
и значением со стека (`X`).

---

## 5. Дамп памяти (XML)

После выполнения программы интерпретатор сохраняет содержимое памяти в XML-файл в диапазоне адресов `[start, end)`:

```python
def dump_xml(self, out_path: str, start: int, end: int) -> None:
    root = ET.Element("memory")
    root.set("start", str(start))
    root.set("end", str(end))

    for addr in range(start, end):
        cell = ET.SubElement(root, "cell")
        cell.set("addr", str(addr))
        cell.set("value", str(self.mem_get(addr)))

    tree = ET.ElementTree(root)
    tree.write(out_path, encoding="utf-8", xml_declaration=True)
```

Пример структуры дампа:

```xml
<memory start="95" end="205">
    <cell addr="95" value="0"/>
    <cell addr="100" value="10"/>
    ...
</memory>
```

---

## 6. Тестовая программа копирования массива

Для демонстрации работоспособности интерпретатора создана программа:

`programs/copy_demo.yaml`

### Логика программы

#### **Инициализация массива по адресам 100..102 значениями 10, 20, 30:**

```yaml
- { op: CONST, value: 10 }
- { op: CONST, value: 100 }
- { op: STORE }

- { op: CONST, value: 20 }
- { op: CONST, value: 101 }
- { op: STORE }

- { op: CONST, value: 30 }
- { op: CONST, value: 102 }
- { op: STORE }
```

#### **Копирование значений в адреса 200..202:**

```yaml
# mem[200] = mem[100]
- { op: LOAD,  addr: 100 }
- { op: CONST, value: 200 }
- { op: STORE }

# mem[201] = mem[101]
- { op: LOAD,  addr: 101 }
- { op: CONST, value: 201 }
- { op: STORE }

# mem[202] = mem[102]
- { op: LOAD,  addr: 102 }
- { op: CONST, value: 202 }
- { op: STORE }
```

После выполнения программы значения `mem[200..202]` совпадают с `mem[100..102]`, что подтверждается дампом памяти.

---

## 7. Запуск интерпретатора (Этап 3)

### 1) Сначала собрать бинарный файл из YAML-программы:

```bash
python assembler.py programs/copy_demo.yaml build/copy_demo.bin
```

### 2) Затем выполнить программу и сформировать дамп памяти:

```bash
python interpreter.py build/copy_demo.bin build/copy_dump.xml --start 95 --end 205
```

После выполнения будет создан файл:

```
build/copy_dump.xml
```

В нём отображается содержимое памяти, включая инициализированный и скопированный массив.

---

## 8. Результат Этапа 3

После выполнения Этапа 3 у нас есть:

* интерпретатор УВМ для варианта 30 (`interpreter.py`);
* объединённая модель памяти (код и данные в одном адресном пространстве);
* реализация команд `CONST`, `LOAD`, `STORE`, `MAX`;
* сохранение дампа памяти в XML-формате для любого диапазона адресов;
* тестовая программа `copy_demo.yaml`, демонстрирующая корректную работу интерпретатора и операции копирования массива.


