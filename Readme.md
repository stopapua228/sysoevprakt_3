# Этап 1 — Ассемблер УВМ (Вариант 30)
## Автор: Сысоев Даниил Денисович, ИКБО-71-24  

## 1. Что происходит в этапе

Этап 1 заключается в создании минимального ассемблера, который:

* принимает программу в формате **YAML**;
* формирует внутреннее представление инструкций (A, B);
* кодирует их в 32-битные машинные слова согласно условиям варианта 30;
* в режиме `--test` выводим:

  * IR (список инструкций с полями A/B),
  * hex-дамп полученного бинарника,
  * размер сгенерированного `.bin` файла.

#  ВАЖНО Установить зависимости:

```bash
pip install -r requirements.txt
```

---

### Запуск в тестовом режиме

Создать папку для бинарников:

```bash
mkdir build
```
Собрать и протестировать программу:
```bash
python assembler.py programs/tests.yaml build/tests.bin --test
```
### Что выдаёт `--test`:
1. Внутреннее представление инструкций (A, B).
2. Hex-дамп 32-битных слов.
3. Размер итогового бинарного файла.
Вывод должен совпадать с тестами из спецификации:
* CONST 480 → `08 3C 00 00`
* LOAD 91 → `75 0B 00 00`
* STORE → `1C 00 00 00`
* MAX 6 → `D9 00 00 00`



---

# 3. Спроектированный язык ассемблера (формат входной программы)1

В рамках Этапа 1 был разработан простой и человекочитаемый язык ассемблера для учебной виртуальной машины (УВМ), вариант 30.
В качестве формата представления программы выбран **YAML**, так как он:

* легко читается человеком;
* формирует структуру данных, которую удобно обрабатывать в Python;
* естественно подходит для списков инструкций.

---

## 3.1. Общий формат файла программы

Программа представляет собой **список инструкций**, каждая из которых оформлена в виде YAML-объекта следующего вида:

```yaml
- { op: <имя_команды>, <аргументы> }
```

Каждая инструкция находится на отдельной строке и имеет обязательное поле:

* `op` — имя операции (команды), регистр не важен.

Дополнительные поля (`value`, `addr`, `offset`) зависят от типа команды.

Например:

```yaml
- { op: CONST, value: 480 }
- { op: LOAD,  addr: 91 }
- { op: STORE }
- { op: MAX,   offset: 6 }
```

---

## 3.2. Поддерживаемые инструкции (вариант 30)

Ассемблер реализует четыре команды, определённые спецификацией УВМ для варианта 30.
Для каждой команды задаётся:

* имя (`op`);
* аргументы, необходимые для вычисления поля B;
* назначение команды.

### **1) CONST**

```yaml
- { op: CONST, value: <число> }
```

| Аргумент | Описание                                                                             |
| -------- | ------------------------------------------------------------------------------------ |
| `value`  | Константа, которая кодируется в поле B и помещается на вершину стека при исполнении. |

### **2) LOAD**

```yaml
- { op: LOAD, addr: <адрес> }
```

| Аргумент | Описание                                                                |
| -------- | ----------------------------------------------------------------------- |
| `addr`   | Адрес в памяти; при исполнении значение `mem[addr]` помещается на стек. |

### **3) STORE**

```yaml
- { op: STORE }
```

Команда не принимает аргументов.
При исполнении берёт со стека два значения: адрес и данные, и записывает данные в память по указанному адресу.

### **4) MAX**

```yaml
- { op: MAX, offset: <смещение> }
```

| Аргумент | Описание                                                                                                                                                                      |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `offset` | Смещение, добавляемое к базовому адресу, снимаемому со стека. Команда вычисляет максимум двух операндов: значения в памяти `mem[base + offset]` и значения, лежащего в стеке. |

---

## 3.3. Валидация аргументов

Ассемблер проверяет:

1. корректность имени команды;
2. наличие обязательных аргументов (`value`, `addr`, `offset`);
3. соответствие аргументов допустимому диапазону поля B:

   * CONST → 21 бит
   * LOAD → 24 бита
   * MAX → 13 бит

Если значение не помещается в указанный диапазон, ассемблер выдаёт ошибку.

---

## 3.4. Преимущества выбранного формата

Использование YAML позволяет:

* минимизировать синтаксические ошибки;
* упростить разбор и обработку инструкций;
* легко добавлять новые команды в будущем;
* обеспечивать читаемость и прозрачность входной программы.

Такой формат является удобным для учебного ассемблера и полностью удовлетворяет требованиям Этапа 1.



---
## 4. Результат Этапа 1
После выполнения Этапа 1 у нас есть:
* рабочий ассемблер для варианта 30;
* проверка на тестах из задания;
* генерация бинарного `.bin` файла;
* вывод IR и hex-дампа.




---

# 3. Спроектированный язык ассемблера (формат входной программы)

В рамках Этапа 1 был разработан простой и человекочитаемый язык ассемблера для учебной виртуальной машины (УВМ), вариант 30.
В качестве формата представления программы выбран **YAML**, так как он:

* легко читается человеком;
* формирует структуру данных, которую удобно обрабатывать в Python;
* естественно подходит для списков инструкций.

---

## 3.1. Общий формат файла программы

Программа представляет собой **список инструкций**, каждая из которых оформлена в виде YAML-объекта следующего вида:

```yaml
- { op: <имя_команды>, <аргументы> }
```

Каждая инструкция находится на отдельной строке и имеет обязательное поле:

* `op` — имя операции (команды), регистр не важен.

Дополнительные поля (`value`, `addr`, `offset`) зависят от типа команды.

Например:

```yaml
- { op: CONST, value: 480 }
- { op: LOAD,  addr: 91 }
- { op: STORE }
- { op: MAX,   offset: 6 }
```

---

## 3.2. Поддерживаемые инструкции (вариант 30)

Ассемблер реализует четыре команды, определённые спецификацией УВМ для варианта 30.
Для каждой команды задаётся:

* имя (`op`);
* аргументы, необходимые для вычисления поля B;
* назначение команды.

### **1) CONST**

```yaml
- { op: CONST, value: <число> }
```

| Аргумент | Описание                                                                             |
| -------- | ------------------------------------------------------------------------------------ |
| `value`  | Константа, которая кодируется в поле B и помещается на вершину стека при исполнении. |

### **2) LOAD**

```yaml
- { op: LOAD, addr: <адрес> }
```

| Аргумент | Описание                                                                |
| -------- | ----------------------------------------------------------------------- |
| `addr`   | Адрес в памяти; при исполнении значение `mem[addr]` помещается на стек. |

### **3) STORE**

```yaml
- { op: STORE }
```

Команда не 12принимает аргументов.
При исполнении берёт со стека два значения: адрес и данные, и записывает данные в память по указанному адресу.

### **4) MAX**

```yaml
- { op: MAX, offset: <смещение> }
```

| Аргумент | Описание                                                                                                                                                                      |
| -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `offset` | Смещение, добавляемое к базовому адресу, снимаемому со стека. Команда вычисляет максимум двух операндов: значения в памяти `mem[base + offset]` и значения, лежащего в стеке. |

---

## 3.3. Валидация аргументов

Ассемблер проверяет:

1. корректность имени команды;
2. наличие обязательных аргументов (`value`, `addr`, `offset`);
3. соответствие аргументов допустимому диапазону поля B:

   * CONST → 21 бит
   * LOAD → 24 бита
   * MAX → 13 бит

Если значение не помещается в указанный диапазон, ассемблер выдаёт ошибку.

---

## 3.4. Преимущества выбранного формата

Использование YAML позволяет:

* минимизировать синтаксические ошибки;
* упростить разбор и обработку инструкций;
* легко добавлять новые команды в будущем;
* обеспечивать читаемость и прозрачность входной программы.

Такой формат является удобным для учебного ассемблера и полностью удовлетворяет требованиям Этапа 1.


## Этап 2 — Формирование машинного кода

На втором этапе задача ассемблера — не только разобрать входную программу, но и **сформировать корректный бинарный файл с машинным кодом УВМ**.

### 2.1. Формат машинного слова

Каждая команда УВМ кодируется одним 32-битным словом (4 байта) в формате *little-endian*:

- биты **0–4** — поле `A` (код операции);
- биты **5..N** — поле `B` (аргумент команды), разрядность зависит от операции:
  - `CONST` — 21 бит (5–25);
  - `LOAD`  — 24 бита (5–28);
  - `MAX`   — 13 бит (5–17);
  - `STORE` — поле `B` отсутствует.

Машинное слово формируется так:

```python
value = A
if B is not None:
    value |= (B << 5)
value &= 0xFFFFFFFF  # защита от переполнения
