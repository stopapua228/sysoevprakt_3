# УВМ (Учебная виртуальная машина) — Вариант 30 — Этапы 1–3
**Автор:** Сысоев Даниил Денисович, ИКБО-71-24

Проект состоит из:
- `assembler.py` — ассемблер: YAML → 32-битный машинный код → `.bin`
- `interpreter.py` — интерпретатор: `.bin` → выполнение команд → XML-дамп памяти
- `programs/*.yaml` — программы на “языке ассемблера” (YAML)

---

## 0. Структура проекта

Рекомендуемая структура:

```

uvm-v30/
│
├── assembler.py
├── interpreter.py
├── requirements.txt
├── README.md
│
└── programs/
├── tests.yaml
└── copy_demo.yaml

````

Папка `build/` создаётся локально для результатов сборки (её обычно не коммитят).

---

## 1. Установка и подготовка

### 1.1. Установка зависимостей

```bash
pip install -r requirements.txt
````

### 1.2. Создание папки для результатов

```bash
mkdir build
```

---

## 2. Этап 1 — Ассемблер + тестовый режим (IR и Hex)

### 2.1. Что делаем на этапе 1

На этапе 1 реализован минимальный ассемблер, который:

* принимает программу в формате **YAML**;
* формирует внутреннее представление команд (IR: `op`, `A`, `B`, `word`);
* кодирует команды в **32-битные машинные слова** (вариант 30);
* в режиме `--test` печатает:

  * IR,
  * hex-дамп байтов бинарного файла.

### 2.2. Запуск этапа 1 (тестовый режим)

```bash
python assembler.py programs/tests.yaml build/tests.bin --test
```

Ожидаемые байты для теста варианта 30 (как в спецификации УВМ):

* CONST 480 → `08 3C 00 00`
* LOAD 91 → `75 0B 00 00`
* STORE → `1C 00 00 00`
* MAX 6 → `D9 00 00 00`

> `IR` (Intermediate Representation) — внутреннее промежуточное представление команд в удобном для отладки виде.
> `Hex-дамп` — печать байтов бинарника в шестнадцатеричном формате (как в тестах).

---

## 3. Этап 2 — Формирование машинного кода и запись `.bin`

### 3.1. Что делаем на этапе 2

На этапе 2 ассемблер обязан:

1. реализовать трансляцию из промежуточного представления в машинное (32-битное слово);
2. записать результат ассемблирования в бинарный файл `.bin`;
3. вывести размер бинарного файла в байтах;
4. в режиме тестирования вывести байты в формате как в спецификации УВМ;
5. иметь YAML-программу, которая покрывает все тестовые байтовые последовательности (в нашем случае `programs/tests.yaml`).

### 3.2. Формат машинного слова (вариант 30)

Каждая команда — 32-битное слово (4 байта), little-endian.

* биты **0..4**: поле `A` (код операции, 5 бит)
* биты **5..N**: поле `B` (аргумент, разрядность зависит от команды)

Трансляция выполняется формулой:

```python
word = A | (B << 5)
```

Разрядность B:

* `CONST`: 21 бит
* `LOAD`: 24 бита
* `MAX`: 13 бит
* `STORE`: B отсутствует

### 3.3. Запись бинарника и вывод размера (основной запуск этапа 2)

```bash
python assembler.py programs/tests.yaml build/tests.bin
```

Ожидаемый результат для `tests.yaml`:

* 4 команды × 4 байта = **16 байт**
* в консоли будет:

  * количество команд,
  * размер бинарника в байтах.

### 3.4. Проверка бинарника в hex (без установки программ)

В Windows PowerShell:

```powershell
Format-Hex build\tests.bin
```

---

## 4. Язык ассемблера (входной формат YAML)

Программа — это список инструкций. Каждая инструкция — YAML-объект с полем `op` и аргументами.

Пример (tests.yaml):

```yaml
- { op: CONST, value: 480 }
- { op: LOAD,  addr: 91 }
- { op: STORE }
- { op: MAX,   offset: 6 }
```

Поддерживаемые инструкции (вариант 30):

* `CONST` — `{ op: CONST, value: <число> }`
* `LOAD`  — `{ op: LOAD,  addr: <адрес> }`
* `STORE` — `{ op: STORE }`
* `MAX`   — `{ op: MAX,   offset: <смещение> }`

Ассемблер валидирует диапазоны B по разрядности (21/24/13 бит).

---

# 5. Этап 3 — Интерпретатор УВМ и дамп памяти (XML)

## 5.1. Что делаем на этапе 3

На этапе 3 реализуется **интерпретатор** (виртуальная машина), который:

* загружает бинарный файл `.bin`;
* декодирует каждое 32-битное слово в `A` и `B`;
* выполняет команды на **стековой модели**;
* использует **объединённую память** (код и данные в одном адресном пространстве);
* сохраняет **дамп памяти** в XML для диапазона адресов `[start, end)`.

Интерпретатор реализован в `interpreter.py`.

---

## 5.2. Модель памяти и стек

Виртуальная машина `VM` содержит:

* `mem: dict[int, int]` — разреженная объединённая память (адрес → 32-битное значение),
* `stack: list[int]` — стек значений,
* `pc: int` — счётчик команд (индекс текущей инструкции),
* `prog_len: int` — количество команд в программе.

Код программы загружается в память с адреса `0`, то есть команды лежат в `mem[0..prog_len-1]`.

---

## 5.3. Декодирование машинного слова

Декодирование обратное ассемблеру:

* `A = word & 0x1F`
* `B = (word >> 5) & mask` (если B есть)

---

## 5.4. Реализованные команды (исполнение)

* `CONST B`: кладёт `B` на стек
* `LOAD B`: кладёт `mem[B]` на стек
* `STORE`: снимает со стека `ADDR` и `VALUE` и делает `mem[ADDR] = VALUE`

  * формат стека перед STORE: `[..., VALUE, ADDR]`
* `MAX offset`: снимает `BASE` и `X`, читает `mem[BASE + offset]`, кладёт `max(X, mem[BASE+offset])`

---

## 5.5. Дамп памяти (XML)

После выполнения программа сохраняет XML вида:

```xml
<memory start="95" end="205">
  <cell addr="100" value="10"/>
  <cell addr="200" value="10"/>
  ...
</memory>
```

Диапазон задаётся параметрами `--start` и `--end`.

---

## 5.6. Тестовая программа этапа 3 — копирование массива

Файл: `programs/copy_demo.yaml`

Логика:

1. записываем значения 10, 20, 30 в `mem[100..102]`;
2. копируем их в `mem[200..202]`.

---

## 5.7. Запуск этапа 3 (сборка + выполнение)

1. Собрать бинарник из программы копирования:

```bash
python assembler.py programs/copy_demo.yaml build/copy_demo.bin
```

2. Запустить интерпретатор и сделать дамп памяти:

```bash
python interpreter.py build/copy_demo.bin build/copy_dump.xml --start 95 --end 205
```

### Как проверить результат

Открой `build/copy_dump.xml` и убедись, что:

* `addr="100" value="10"`, `addr="101" value="20"`, `addr="102" value="30"`
* `addr="200" value="10"`, `addr="201" value="20"`, `addr="202" value="30"`

Это доказывает, что массив успешно скопирован.

---

## 6. Результат выполнения этапов 1–3

На текущем этапе реализовано:

* ассемблер для варианта 30 (YAML → 32-битный машинный код);
* запись бинарного файла `.bin` и вывод размера в байтах;
* тестовый режим с IR и hex-дампом;
* интерпретатор УВМ (стек + объединённая память);
* XML-дамп памяти в диапазоне адресов;
* тестовая программа копирования массива (этап 3).

```

